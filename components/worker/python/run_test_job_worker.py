import os
from typing import List
from datetime import datetime
import requests
import traceback

# Check if environment variable is set, exit in error if it's not
from ...common.python.util.sys_util import SysUtil
SysUtil.ensure_env_var_set('COSIMS_DB_HTTP_API_BASE_URL')

from ...common.python.database.model.job.test_job import TestJob
from ...common.python.database.model.job.system_parameters import SystemPrameters
from ...common.python.database.logger import Logger
from ...common.python.util.exceptions import CsiExternalError, CsiInternalError
from .run_worker_template import RunWorker


class RunTestJobWorker(RunWorker):
    '''
    Class of "run_worker" object in charge of setting up a worker and run the
    dockerized scientific Snow and Ice software on it to generate FSC/RLIE
    products from L1C, L2A input.

    :param root_dir: path leading to the directory in which will be stored all
        the temporary files needed and/or generated by the processing.
    '''

    def __init__(self, job, logger):

        # Call the parent constructor BEFORE all the attributes are initialized
        super().__init__(root_dir=os.environ['CSI_ROOT_DIR'])

        self.input_products = "test_job_input"  # Name of the input folder
        self.logger = logger                    # Logger object
        self.job = job                          # Job instance of type TestJob


# Start of mandatory methods
    def job_pre_processing(self):

        self.logger.info(f"Test job {self.job.id} pre_processing...")


    def job_processing(self):

        self.logger.info(f"Test job {self.job.id} processing...")
        docker_image = SystemPrameters().get(self.logger.debug).docker_image_for_test_job_processing
        processing_exe_name = 'test_job_processing_chain.py'
        container_command = f'{processing_exe_name}'
        work_dir = self.get_work_dir()

        try:
            si_processing_status = self.run_processing_in_docker(
                image_name=docker_image,
                container_name=f'test_job_processing_{self.job.id}',
                command=container_command,
                volumes_binding={
                    f'{work_dir}': { # The local working dir
                        'bind': self.get_container_work_dir(), # the dir in the container, something like '/work'
                        'mode': 'rw'
                        }
                    },
                logger=self.logger
                )

        except requests.exceptions.ConnectionError as error:
            message = f"Failed to establish connection with docker to run test_job software !"\
                f"\nerror : {error}"
            external_error = CsiExternalError('Docker connection error', message)
            raise external_error from error


    def job_post_processing(self):

        self.logger.info(f"Test job {self.job.id} post_processing...")
        self.job.completion_date = datetime.datetime.now()
        self.logger.info(f'update some job informations')
        self.job.patch(patch_foreign=True, logger_func=self.logger.debug)

# Function does the minimal stuff to get a valid job, an associate logger and
# launches the 'run' function which actually executes the tasks. This function
# catch errors from 'run' command and "sends" them to the database (with the
# status change).
def main(job_id: int):
    jobs: List[TestJob] = TestJob().id_eq(job_id).get()

    if len(jobs) == 0:
        print(f'there is no job which ID is {job_id}')
        exit(1)

    job = jobs[0]
    logger = Logger(job.post_new_execution_info())

    # Create an instance of the RunWorker class to process the job..
    run_worker_instance = RunTestJobWorker(job, logger)

    try:
        run_worker_instance.run()
        logger.info('run finished')
        error = None
    except Exception as exception:
        error = exception
        if not isinstance(error, (CsiInternalError, CsiExternalError)):
            logger.error(traceback.format_exc())
    finally:
        run_worker_instance.error_management_and_exit(
            error
        )
# End of mandatory methods
